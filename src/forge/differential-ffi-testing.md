## Differential Testing

Forge can enable differential testing across languages and implementations using the `ffi` [cheatcode](../cheatcodes/ffi.md).

[Differential testing](https://en.wikipedia.org/wiki/Differential_testing) cross references multiple implementations of the same function by comparing each one's output. Imagine we have a function specification `F(X)`, and two implementations of that specification: `f1(X)` and `f2(X)`. We expect `EQ(f1(x), f2(x))` for all x that exist in an appropriate input space and some equality function EQ. If `!EQ(f1(x), f2(x))`, we know that at least one function is incorrectly implementing `F(X)`. This process of testing for equality and identifying discrepancies is the core of differential testing.

Some real life uses include:
* Comparing upgraded implementations to their predecessors
* Testing code against known reference implementations
* Confirming compatability with third party tools and dependencies

Goal #1 can already be easily implemented using forge's [fuzz testing](./fuzz-testing.md). You simply need to write a test that calls both contracts with the fuzzed input and ensure the results match.

Let's see how Foundry tackles some more complex differential testing.

### Primer: The `ffi` cheatcode

`ffi` allows you to execute an arbitrary shell command and capture the output. Here's a mock example:
```soldity
import "forge-std/Test.sol";

contract TestContract is Test {

    function testMyFFI () public {
        string[] memory cmds = new string[](2);
        cmds[0] = "cat";
        cmds[1] = "address.txt"; // assume contains abi-encoded address.
        bytes memory result = vm.ffi(cmds);
        address loadedAddress = abi.decode(result, (address));
        // Do something with the address
        // ...
    }
}
```
An address has previously been written to `address.txt`, and we read it in using the cheatcode.
FFI makes differential testing against other implementations possible within a Foundry test.


### Case Study: Differential Testing Merkle Tree Implementations
[Merkle Trees](https://en.wikipedia.org/wiki/Merkle_tree) are a cryptographic commitmentment scheme frequently used in blockchain applications. Their popularity means there are a number of different implementations of Merkle Tree generators, provers, and verifiers. Often, Merkle roots and proofs are generated uisng a language like Javascript or Python, and proofs are verified on-chain in solidity.

[Murky](https://github.com/dmfxyz/murky) is a complete implementation of Merkle roots, proofs, and verification in solidity. Its test suite includes differential tests against OpenZeppelin's Merkle proof verification implementation, as well as root generation tests against a reference Javascript implementation. These tests are powered by Foundry's fuzzing and `ffi` capabilities.

#### Differential Testing against reference TypeScript implementation
Using the `ffi` cheatcode, Murky tests its own Merkle root implementation against a TypeScript implementation using randomized data:

TODO: !DMFXYZ! Update this to the differential fuzzed version
```solidity
    function testMerkleRootMatchesJSImplementation() public {
        // Run the reference implementation in javascript
        string[] memory runJsInputs = new string[](6);
        runJsInputs[0] = 'npm';
        runJsInputs[1] = '--prefix';
        runJsInputs[2] = 'differential_testing/scripts/';
        runJsInputs[3] = '--silent';
        runJsInputs[4] = 'run';
        runJsInputs[5] = 'generate-root';
        bytes memory jsResult = vm.ffi(runJsInputs);
        bytes32 jsGeneratedRoot = abi.decode(jsResult, (bytes32));

        // Read in the file generated by the reference implementation 
        string[] memory loadJsDataInputs = new string[](2);
        loadJsDataInputs[0] = "cat";
        loadJsDataInputs[1] = "differential_testing/data/input";
        bytes memory loadResult =  vm.ffi(loadJsDataInputs);
        data  = abi.decode(loadResult, (bytes32[100]));

        // Calculate root using Murky
        bytes32 murkyGeneratedRoot = m.getRoot(_getData());
        assertEq(murkyGeneratedRoot, jsGeneratedRoot);
    }
```

In this example, the first FFI command is `npm --prefix differential_testing/scripts/ --silent run generate-root`. This compiles and runs a JavaScript script. The script generates 100 random 32 byte values, calculates the Merkle root using a reference implementation, and then dumps the values into the file `differential_testing/data/input`. The script prints the calculated root to stdout, which is captured as `bytes` in the return value of `vm.ffi()`.

The second FFI command reads in the generated file, decodes the 100 values used by the reference implementation, and uses Murky's root generation implementation to calculate the tree's root.

Finally, the test asserts that the both roots are exactly equal. If not, the test fails.

#### Fuzzed Differential Testing against OpenZeppelin Prover
TODO: !DMFXYZ! This section








