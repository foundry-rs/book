---
description: Executes calls to an address using bytecode from another address
---

## `mockFunction`

### Signature

```solidity
function mockFunction(address callee, address target, bytes calldata data) external;
```

### Description

Executes calls to an address `callee` with bytecode of address `target` if the call data either strictly or loosely matches `data`.

When a call is made to `callee`, the call data is first checked to see if it matches in its entirety with `data`. If not, the call data is checked to see if there is a partial match on function selector.

If a match is found, then the call is executed using the bytecode of `target` address.

### Parameters

| Parameter | Type      | Description                                            |
|-----------|-----------|--------------------------------------------------------|
| `callee`  | `address` | The address whose calls will be intercepted            |
| `target`  | `address` | The address whose bytecode will be used for execution  |
| `data`    | `bytes`   | The calldata to match (can be partial selector)        |

### Examples

Given two contracts with the same storage layout:

```solidity
contract Counter {
    uint256 public a;

    function count(uint256 x) public {
        a = 321 + x;
    }
}

contract ModelCounter {
    uint256 public a;

    function count(uint256 x) public {
        a = 123 + x;
    }
}
```

#### Mocking an exact call

```solidity [test/MockFunctionExact.t.sol]
function testMockFunctionExact() public {
    vm.mockFunction(
        address(counter),
        address(model),
        abi.encodeWithSelector(Counter.count.selector, 456)
    );
    
    counter.count(456);
    assertEq(counter.a(), 123 + 456); // Uses model's logic
    
    counter.count(567);
    assertEq(counter.a(), 321 + 567); // Uses counter's logic
}
```

#### Mocking all calls to a function

```solidity [test/MockFunctionAll.t.sol]
function testMockFunctionAll() public {
    vm.mockFunction(
        address(counter),
        address(model),
        abi.encodeWithSelector(Counter.count.selector)
    );
    
    counter.count(678);
    assertEq(counter.a(), 123 + 678); // Uses model's logic
    
    counter.count(789);
    assertEq(counter.a(), 123 + 789); // Uses model's logic
}
```

### Gotchas

:::warning
The `callee` and `target` contracts must have compatible storage layouts. State changes are written to `callee`'s storage, but executed using `target`'s bytecode.
:::

:::note
This cheatcode does not work in isolated test mode.
:::

### Related Cheatcodes

- [`mockCall`](/reference/cheatcodes/mock-call) - Mock calls to return specific data
- [`etch`](/reference/cheatcodes/etch) - Set bytecode at an address
